@page "/"

@using System.IO
@using PlexSanitizer.Models
@using PlexSanitizer.Services

@inject IFolderSanitizerService FolderSanitizerService
@inject IDialogService DialogService

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Plex Folder Sanitizer</MudText>

    <MudGrid>
        <MudItem xs="12">
            <MudPaper Class="pa-4">
                <MudText Typo="Typo.h5" Class="mb-4">Select Source Folder</MudText>
                <MudAlert Severity="Severity.Info" Class="mb-4">
                    <MudText Typo="Typo.body2">
                        <strong>Supported path formats:</strong><br />
                        • Local paths: <code>C:\Users\Username\Documents</code><br />
                        • Full network paths: <code>\\server\share\folder</code><br />
                        <br />
                        <strong>Note:</strong> Mapped drives (Z:, Y:, etc.) are not supported. Please use the full network path instead.
                    </MudText>
                </MudAlert>
                
                <MudTextField @bind-Value="SourceFolder" Immediate
                             Label="Folder Path" 
                             Placeholder="Paste or type the folder path here (e.g., C:\Folder or \\server\share\folder)"
                             Variant="Variant.Outlined" 
                             Adornment="Adornment.Start" 
                             AdornmentIcon="@Icons.Material.Filled.FolderOpen" 
                             FullWidth="true"
                             Class="mud-input-large-text"
                             Style="font-size: 1.2rem;"
                             Lines="1"
                             HelperText="Tip: You can copy a folder path from Windows Explorer's address bar and paste it here" />

                <MudDivider Class="my-4" />

                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ScanFolders" 
                        Disabled="@(string.IsNullOrEmpty(SourceFolder))" Class="mb-4">
                    Scan Folders
                </MudButton>

                @if (IsLoading)
                {
                    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
                }


                @if (Folders != null && Folders.Any())
                {
                    <MudExpansionPanels>
                        <MudExpansionPanel Text="Sanitization Rules" IsInitiallyExpanded="true">
                            <MudList T=bool Dense="true">
                                @for (int i = 0; i < SanitizationRules.Count; i++)
                                {
                                    var rule = SanitizationRules[i];
                                    var index = i;
                                    <MudListItem>
                                        <MudCheckBox T="bool" Value="rule.IsActive" Color="Color.Primary" 
                                                    ValueChanged="@(isChecked => ToggleRule(index, isChecked))" />
                                        <MudText Typo="Typo.body1" Class="ml-2">@rule.Name</MudText>
                                        <MudText Typo="Typo.caption" Class="ml-4">@rule.Description</MudText>
                                    </MudListItem>
                                }
                            </MudList>
                        </MudExpansionPanel>
                    </MudExpansionPanels>

                    <MudDivider Class="my-4" />

                    <MudPaper Class="pa-4 mb-4">
                        <MudText Typo="Typo.h6" Class="mb-2">Preview Changes</MudText>
                        <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="PreviewChanges" 
                                  Class="mb-4">
                            Refresh Preview
                        </MudButton>
                        
                        <MudTable Items="@Folders" Dense="true" Hover="true" Bordered="true" Striped="true" 
                                 Style="max-height: 600px; overflow-y: auto;">
                            <ColGroup>
                                <col style="width: 50px;" />
                                <col style="width: 45%;" />
                                <col style="width: 45%;" />
                                <col style="width: 80px;" />
                            </ColGroup>
                            <HeaderContent>
                                <MudTh>
                                    <MudCheckBox @bind-Value="@SelectAll" Color="Color.Primary" />
                                </MudTh>
                                <MudTh>Original Name</MudTh>
                                <MudTh>Sanitized Name</MudTh>
                                <MudTh>Change</MudTh>
                            </HeaderContent>
                            <RowTemplate>
                                <MudTd DataLabel="">
                                    <MudCheckBox @bind-Value="@context.IsSelected" Color="Color.Primary" />
                                </MudTd>
                                <MudTd DataLabel="Original" Style="word-break: break-all; white-space: normal;">
                                    @context.Name
                                </MudTd>
                                <MudTd DataLabel="Sanitized" Style="word-break: break-all; white-space: normal;">
                                    @(string.IsNullOrEmpty(context.NewName) ? context.Name : context.NewName)
                                </MudTd>
                                <MudTd DataLabel="Change">
                                    @if (context.HasChanges)
                                    {
                                        <MudChip T=bool Color="Color.Success" Size="Size.Small">Yes</MudChip>
                                    }
                                    else
                                    {
                                        <MudChip T=bool Color="Color.Default" Size="Size.Small">No</MudChip>
                                    }
                                </MudTd>
                            </RowTemplate>
                        </MudTable>
                    </MudPaper>

                    <MudPaper Class="d-flex justify-end pa-4 mt-2" Elevation="0">
                        <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="ApplySanitization" 
                                 Disabled="@(!Folders.Any(f => f.IsSelected && f.HasChanges))">
                            Apply Changes
                        </MudButton>
                    </MudPaper>
                }
            </MudPaper>
        </MudItem>
    </MudGrid>
</MudContainer>

@code {
    private string SourceFolder { get; set; } = string.Empty;
    private List<FolderItem> Folders { get; set; } = new List<FolderItem>();
    private List<FolderSanitizationRule> SanitizationRules { get; set; } = new List<FolderSanitizationRule>();
    private bool IsLoading { get; set; } = false;
    private bool _selectAll = true;

    protected override void OnInitialized()
    {
        SanitizationRules = FolderSanitizerService.GetRules();
    }

    private bool SelectAll
    {
        get => _selectAll;
        set
        {
            if (_selectAll != value)
            {
                _selectAll = value;
                foreach (var folder in Folders)
                {
                    folder.IsSelected = value;
                }
            }
        }
    }

    private void ToggleRule(int index, bool isChecked)
    {
        FolderSanitizerService.ToggleRule(index, isChecked);
        // Recalculate the preview if needed
        if (Folders.Any())
        {
            PreviewChanges();
        }
    }
    
    private async Task ScanFolders()
    {
        if (string.IsNullOrEmpty(SourceFolder))
        {
            Toast.Add("Please select a source folder", Severity.Warning);
            return;
        }

        try
        {
            IsLoading = true;
            Folders = await FolderSanitizerService.GetFoldersAsync(SourceFolder);
            
            if (!Folders.Any())
            {
                Toast.Add("No folders found in the selected directory", Severity.Info);
            }
            else
            {
                // Use the proper method in the FolderSanitizerService to check if path exists
                bool pathExists = await FolderSanitizerService.PathExistsAsync(SourceFolder);
                
                if (!pathExists)
                {
                    Toast.Add($"Path '{SourceFolder}' not accessible. Using example data for demonstration.", Severity.Warning);
                }
                else 
                {
                    Toast.Add($"Found {Folders.Count} folders in {SourceFolder}", Severity.Success);
                }
                
                SelectAll = true;
                
                // Automatically preview changes
                await PreviewChanges();
            }
        }
        catch (NotSupportedException ex)
        {
            Debug.WriteLine($"Mapped drive not supported: {ex.Message}");
            Toast.Add(ex.Message, Severity.Error);
            
            // Show a more detailed explanation in a second toast
            Toast.Add("Please use full network paths (e.g., \\\\server\\share) or local paths (e.g., C:\\folder) instead.", Severity.Info);
            
            // Clear the source folder field
            SourceFolder = string.Empty;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error scanning folders: {ex.Message}");
            Toast.Add($"Error scanning folders: {ex.Message}", Severity.Error);
            
            // If folders were not loaded, initialize with empty list
            if (Folders == null)
            {
                Folders = new List<FolderItem>();
            }
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task PreviewChanges()
    {
        if (!Folders.Any())
        {
            return;
        }

        try
        {
            IsLoading = true;
            Folders = await FolderSanitizerService.PreviewSanitizationAsync(Folders);
            
            int changesCount = Folders.Count(f => f.HasChanges);
            if (changesCount > 0)
            {
                Toast.Add($"Preview: {changesCount} folders will be renamed", Severity.Info);
            }
            else
            {
                Toast.Add("No changes needed for these folders", Severity.Info);
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error previewing changes: {ex.Message}");
            Toast.Add("Error generating preview", Severity.Error);
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task ApplySanitization()
    {
        var foldersToRename = Folders.Where(f => f.IsSelected && f.HasChanges).ToList();
        
        if (!foldersToRename.Any())
        {
            Toast.Add("No folders selected for renaming", Severity.Warning);
            return;
        }

        // Check if we're in demo mode
        bool isDemoMode = false;
        try
        {
            // Use reflection to call the private method in the service
            var service = FolderSanitizerService as FolderSanitizerService;
            var method = service.GetType().GetMethod("CheckPathExists", 
                                                    System.Reflection.BindingFlags.NonPublic | 
                                                    System.Reflection.BindingFlags.Instance);
            if (method != null && foldersToRename.Any())
            {
                isDemoMode = !(bool)method.Invoke(service, new object[] { foldersToRename.First().FullPath });
            }
            else
            {
                // Fallback if reflection fails
                isDemoMode = !Directory.Exists(SourceFolder);
            }
        }
        catch
        {
            // Fallback
            isDemoMode = !Directory.Exists(SourceFolder);
        }
        
        string confirmationMessage = isDemoMode
            ? $"DEMO MODE: This will simulate renaming {foldersToRename.Count} folders."
            : $"Are you sure you want to rename {foldersToRename.Count} folders in {SourceFolder}? This cannot be undone.";

        var parameters = new DialogParameters();
        parameters.Add("ContentText", confirmationMessage);
        parameters.Add("ButtonText", isDemoMode ? "Simulate Rename" : "Rename");
        parameters.Add("Color", Color.Error);

        var dialog = await DialogService.ShowAsync<DialogConfirmation>("Confirm Renaming", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            try
            {
                IsLoading = true;
                bool success = await FolderSanitizerService.ApplySanitizationAsync(foldersToRename);

                if (success)
                {
                    if (isDemoMode)
                    {
                        Toast.Add("Rename simulation completed successfully", Severity.Success);
                    }
                    else
                    {
                        Toast.Add("Folders renamed successfully", Severity.Success);
                    }
                    
                    // Refresh the folder list, which will be either real folders or the demo data
                    await ScanFolders();
                }
                else
                {
                    Toast.Add("Some folders could not be renamed. Check permissions or network connectivity.", Severity.Warning);
                    await ScanFolders(); // Refresh folder list
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error applying sanitization: {ex.Message}");
                Toast.Add($"Error renaming folders: {ex.Message}", Severity.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }
    }

    private string GetChangedPart(FolderItem folder)
    {
        if (string.IsNullOrEmpty(folder.Name) || string.IsNullOrEmpty(folder.NewName))
            return string.Empty;
        
        // Find the differences between original and new name
        int i = 0;
        while (i < folder.Name.Length && i < folder.NewName.Length && folder.Name[i] == folder.NewName[i])
            i++;
        
        int j = 0;
        while (j < folder.Name.Length - i && j < folder.NewName.Length - i && 
               folder.Name[folder.Name.Length - 1 - j] == folder.NewName[folder.NewName.Length - 1 - j])
            j++;
        
        // If there are no changes, return empty string
        if (i >= folder.NewName.Length - j)
            return string.Empty;
        
        // Return the changed part
        return folder.NewName.Substring(i, folder.NewName.Length - i - j);
    }
}